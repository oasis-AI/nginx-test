## map 指令（变量映射/白名单/校验）
# 根据请求头 Host 判断是否合法，防止 Host 头攻击。
map $http_host $valid_host {
    default       0;
    # 添加允许的Host头值，使用您的实际IP
    # "localhost:443"   1;
    # "127.0.0.1:443"   1;
    # "127.0.0.1"   1;
    # "~^\d+\.\d+\.\d+\.\d+:443$"  1;  # 匹配任何IP:443格式
    # 如果有固定IP，也可以明确指定
    "27.196.154.146:443"  1;
    "27.196.154.146"  1;
}

# 提取X-Forwarded-For头的第一个IP
map $http_x_forwarded_for $xff_first_ip {
    default "";
    ~^([^,]+) $1;
}

# 判断 X-Forwarded-For 是否存在。
map $http_x_forwarded_for $xff_exists {
    default 0;
    "~." 1;
}

# 检查 XFF 的第一个 IP 是否等于真实客户端 IP。
map "$xff_first_ip:$remote_addr" $xff_matches_remote {
    "~^(.+):(\1)$" 1;  # 使用正则表达式检查两个值是否相同
    default 0;  # 不匹配
}

# 检查 XFF 是否伪造（有 XFF 但和真实 IP 不一致）。
map "$xff_exists:$xff_matches_remote" $is_xff_spoofed {
    "1:0" 1;  # 有XFF但不匹配remote_addr，是伪造
    default 0;  # 其他情况都不是伪造
}

# # 定义有效的 X-Forwarded-For 白名单
# map $http_x_forwarded_for $valid_xff {
#     default       0;
#     ""            1;
#     # 添加允许的 IP 地址
#     # "172.16.0.1"   1;
#     # 可以继续添加其他 IP
#     # 如果需要匹配 IP 段，可以使用正则表达式
#     "~^27\.196\.158\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"  1;
# }

# 检查自定义 st 请求头是否为合法时间戳（10位/13位）。
map $http_st $valid_st_timestamp {
    default   0;                        # 默认无效
    ""        0;                        # 空值无效
    # 验证10位Unix时间戳(秒级)
    "~^[0-9]{10}$"  1;
    # 验证13位Unix时间戳(毫秒级)
    "~^[0-9]{13}$"  1;
}

# 定义有效的Referer白名单, 校验 Referer 是否在白名单。
map $http_referer $valid_referer {
    default     0;
    # "~https?://(localhost|127\.0\.0\.1)(:\d+)?.*"  1;
    "~https?://(27\.196\.159\.69)(:\d+)?.*"        1;
    "~http://(test\.iscenv\.com)(:\d+)?.*"           1;
    # 可以添加更多允许的域名
    # "~https?://example\.com.*"                   1;
    ""                                           1;  # 允许空referer，取决于您的安全要求
}

# 定义有效的Origin白名单, 校验 Origin 是否在白名单。
map $http_origin $valid_origin {
    default     0;
    # "https://localhost"        1;
    # "https://127.0.0.1"        1;
    # "http://localhost"         1;
    # "http://127.0.0.1"         1;
    "https://27.196.159.69"    1;
    "http://27.196.159.69"     1;
    # 可以添加更多允许的origin
    # "https://example.com"    1;
}

# 创建一个组合检查的变量
# 组合 Origin 校验，空 Origin 视为有效。
map $http_origin $check_origin {
    ""        1;  # 空origin视为有效（非浏览器请求）
    default   $valid_origin;  # 否则检查origin是否在白名单中
}

## 定义连接限制区域
# 按 server 名限制并发连接数。
limit_conn_zone $server_name zone=conn_limit_per_server:10m;
# 按客户端 IP 限制并发连接数。
limit_conn_zone $binary_remote_addr zone=conn_limit_per_ip:10m;
# 按客户端 IP 限制请求速率。
limit_req_zone $binary_remote_addr zone=req_limit_per_ip:10m rate=10r/s;


# HTTP 配置（80端口）
server {
    listen 80;
    server_name _;

    # 并发连接数限制。
    # Nginx 的 limit_conn 指令默认值是0，也就是如果你不设置，默认不限制并发连接数
    # 所以注释
    # limit_conn conn_limit_per_server 1000;  # 整个服务器最多1000并发
    # limit_conn conn_limit_per_ip 1000;        # 每个IP最多1000并发
    # 设置当超出限制时的响应状态码(可选)
    # limit_conn_status 429;  # 使用"Too Many Requests"而非默认的503

    # 隐藏 Nginx 版本号，提升安全性。
    server_tokens off;

    # 应对性能测, nginx直接返回
    location = /api/sys_list {
        default_type application/json;
        content_by_lua_file /usr/local/openresty/nginx/lua/sys_list.lua;
    }

    location = /api/operational_system {
        default_type application/json;
        content_by_lua_file /usr/local/openresty/nginx/lua/operational_system.lua;
    }

    location = /api/assignment/task/txt_quality_task/page {
        default_type application/json;
        content_by_lua_file /usr/local/openresty/nginx/lua/txt_quality_task.lua;
    }

    # location 块（反向代理）
    location / {
        
        # proxy_pass http://host.docker.internal:8812;
        # 把所有请求反向代理到 http://ip:port 这个后端服务。
        # proxy_pass http://27.196.154.146:30080;
        proxy_pass http://192.168.0.219:8810;
        # 与后端通信时使用 HTTP/1.1 协议，支持长连接和 WebSocket。
        proxy_http_version 1.1;
        # 设置请求头 Upgrade，用于支持 WebSocket 协议升级。
        proxy_set_header Upgrade $http_upgrade;
        # 设置请求头 Connection: upgrade，配合 WebSocket 使用。
        proxy_set_header Connection 'upgrade';
        # 把客户端请求的 Host 头原样传递给后端，保证后端能获取到真实的 Host 信息。
        proxy_set_header Host $host;
        # 把客户端真实 IP 传递给后端，后端可以通过 X-Real-IP 获取用户真实 IP。
        proxy_set_header X-Real-IP $remote_addr;
        # 把客户端真实 IP 加入 X-Forwarded-For 头，便于后端追踪真实来源。
        proxy_set_header X-Forwarded-For $remote_addr;
        # 把客户端请求协议（http 或 https）传递给后端，后端可感知原始协议。
        proxy_set_header X-Forwarded-Proto $scheme;
        # 如果是 WebSocket 升级请求，则不使用缓存，保证升级请求实时转发。
        proxy_cache_bypass $http_upgrade;
    }

    ## 错误页
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}


# HTTPS配置
server {
    # 监听 443 端口，启用 SSL。
    listen       443 ssl;
    listen  [::]:443 ssl;
    # 使用 _ 表示匹配所有主机名/IP
    server_name _;

    # 隐藏 Nginx 版本号，提升安全性。
    server_tokens off;

    # # 并发连接数限制。
    # limit_conn conn_limit_per_server 1000;  # 整个服务器最多1000并发
    # limit_conn conn_limit_per_ip 10;        # 每个IP最多20并发
    # # 设置当超出限制时的响应状态码(可选)
    # limit_conn_status 429;  # 使用"Too Many Requests"而非默认的503

    # # 添加IP伪造检测（在其他if判断之前或之后）
    # if ($is_xff_spoofed = 1) {
    #     return 403;  # 检测到IP伪造，返回403禁止访问
    # }
    
    # 应用IP伪造检查 (不使用嵌套if)
    # 检查 XFF 伪造，伪造则拒绝。
    if ($is_xff_spoofed) {
        return 403;
    }

    # Host 头不合法直接关闭连接。
    if ($valid_host = 0) {
        return 444;  # 关闭连接，不发送响应头
    }

    # st请求头验证(必须存在且为有效时间戳)
    if ($valid_st_timestamp = 0) {
        return 403;  # 返回禁止访问状态码，st请求头不存在或格式无效
    }

    # # X-Forwarded-For 校验
    # if ($valid_xff = 0) {
    #     return 403;  # 返回禁止访问状态码
    # }

    # Referer校验
    if ($valid_referer = 0) {
        return 403;  # 返回禁止访问状态码
    }
    
    # Origin校验
    if ($check_origin = 0) {
        return 403;  # 返回禁止访问状态码
    }

    ## 优化SSL配置
    # SSL证书配置 - 更新为新证书
    ssl_certificate /etc/nginx/ssl/xyz10.com.pem;
    ssl_certificate_key /etc/nginx/ssl/xyz10.com.key;
    # 允许的 SSL 协议版本。
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    # 加密套件。
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
    # SSL 会话缓存。
    ssl_session_cache shared:SSL:10m;
    # SSL 会话超时时间。
    ssl_session_timeout 10m;

    # location 块（反向代理）
    location / {
        
        # proxy_pass http://host.docker.internal:8812;
        # 把所有请求反向代理到 http://ip:port 这个后端服务。
        proxy_pass http://27.196.154.146:30080;
        # 与后端通信时使用 HTTP/1.1 协议，支持长连接和 WebSocket。
        proxy_http_version 1.1;
        # 设置请求头 Upgrade，用于支持 WebSocket 协议升级。
        proxy_set_header Upgrade $http_upgrade;
        # 设置请求头 Connection: upgrade，配合 WebSocket 使用。
        proxy_set_header Connection 'upgrade';
        # 把客户端请求的 Host 头原样传递给后端，保证后端能获取到真实的 Host 信息。
        proxy_set_header Host $host;
        # 把客户端真实 IP 传递给后端，后端可以通过 X-Real-IP 获取用户真实 IP。
        proxy_set_header X-Real-IP $remote_addr;
        # 把客户端真实 IP 加入 X-Forwarded-For 头，便于后端追踪真实来源。
        proxy_set_header X-Forwarded-For $remote_addr;
        # 把客户端请求协议（http 或 https）传递给后端，后端可感知原始协议。
        proxy_set_header X-Forwarded-Proto $scheme;
        # 如果是 WebSocket 升级请求，则不使用缓存，保证升级请求实时转发。
        proxy_cache_bypass $http_upgrade;
    }

    ## 错误页
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
